default_platform(:ios)

# gRPC‰øÆÊ≠£„ÇíÈÅ©Áî®„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºàÂº∑ÂåñÁâàÔºâ
def apply_grpc_fixes
  require 'xcodeproj'

  begin
    UI.message("üîç Post-build gRPC fixes - Searching for targets in project...")

    # Pods„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    unless Dir.exist?("Pods")
      UI.error("‚ùå Pods directory not found. Skipping gRPC fixes.")
      return
    end

    # ÂÖ®„Å¶„ÅÆxcconfig„Éï„Ç°„Ç§„É´„Å´C++17Ë®≠ÂÆö„ÇíÂº∑Âà∂ÈÅ©Áî®
    UI.message("üìù Applying C++17 fixes to ALL xcconfig files...")

    sh('find Pods -name "*.xcconfig" 2>/dev/null | while IFS= read -r file; do
      echo "üìù Patching $file"
      if ! grep -q "CLANG_CXX_LANGUAGE_STANDARD.*c++17" "$file" 2>/dev/null; then
        echo "CLANG_CXX_LANGUAGE_STANDARD = c++17" >> "$file"
      fi
      if ! grep -q "CLANG_CXX_LIBRARY.*libc++" "$file" 2>/dev/null; then
        echo "CLANG_CXX_LIBRARY = libc++" >> "$file"
      fi
      if ! grep -q "GCC_WARN_INHIBIT_ALL_WARNINGS.*YES" "$file" 2>/dev/null; then
        echo "GCC_WARN_INHIBIT_ALL_WARNINGS = YES" >> "$file"
      fi
      if ! grep -q "OTHER_CPLUSPLUSFLAGS.*-std=c++17" "$file" 2>/dev/null; then
        echo "OTHER_CPLUSPLUSFLAGS = \$(inherited) -std=c++17 -Wno-error=c++20-extensions -Wno-c++20-extensions" >> "$file"
      fi
      echo "‚úÖ Patched $file"
    done')

    # Pods.xcodeproj„ÇíÁõ¥Êé•‰øÆÊ≠£
    pods_project_path = "Pods/Pods.xcodeproj"
    if File.exist?(pods_project_path)
      UI.message("üîß Directly modifying Pods project...")
      pods_project = Xcodeproj::Project.open(pods_project_path)

      pods_project.targets.each do |target|
        target.build_configurations.each do |config|
          # ÂÖ®„Å¶„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà„Å´C++17„ÇíÂº∑Âà∂ÈÅ©Áî®
          config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++17'
          config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-std=c++17'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-error=c++20-extensions'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-c++20-extensions'
          config.build_settings['OTHER_CFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CFLAGS'] << '-Wno-error=c++20-extensions'
          config.build_settings['OTHER_CFLAGS'] << '-Wno-c++20-extensions'

          if target.name.include?('gRPC') || target.name.include?('grpc')
            config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
          end
        end
      end

      pods_project.save
      UI.success("‚úÖ Modified Pods project directly")
    end

    # Áõ¥Êé•„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´„ÇÇ‰øÆÊ≠£
    if File.exist?("Runner.xcworkspace")
      UI.message("üîß Also applying direct Runner project modifications...")
      project = Xcodeproj::Project.open("Runner.xcodeproj")

      project.targets.each do |target|
        target.build_configurations.each do |config|
          config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++17'
          config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-std=c++17' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-std=c++17')
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-error=c++20-extensions' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-Wno-error=c++20-extensions')
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-c++20-extensions' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-Wno-c++20-extensions')
        end
      end

      project.save
      UI.success("‚úÖ Applied project-level C++17 settings")
    end

    # Also fix Agora RTC Engine source code issues
    UI.message("üîß Applying Agora RTC Engine source code fixes...")

    # Try multiple possible paths for agora_rtc_engine
    possible_paths = [
      # Pub cache path (for CI/CD)
      File.expand_path("~/.pub-cache/hosted/pub.dev/agora_rtc_engine-6.5.3/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm"),
      # Local Pods path (for local development)
      "Pods/agora_rtc_engine/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm",
      # Symlink path
      ".symlinks/plugins/agora_rtc_engine/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm"
    ]

    agora_surface_view_factory_path = nil
    possible_paths.each do |path|
      if File.exist?(path)
        agora_surface_view_factory_path = path
        UI.message("üìÅ Found AgoraSurfaceViewFactory.mm at: #{path}")
        break
      end
    end

    if agora_surface_view_factory_path
      # Read the file content
      content = File.read(agora_surface_view_factory_path)

      UI.message("üîç Analyzing AgoraSurfaceViewFactory.mm content...")
      UI.message("   - File size: #{content.length} bytes")
      UI.message("   - Contains 'weakSelf': #{content.include?('weakSelf')}")
      UI.message("   - Contains '__weak typeof(self) weakSelf': #{content.include?('__weak typeof(self) weakSelf')}")

      # Force fix even if our detection is imperfect - apply comprehensive patterns
      if content.include?('weakSelf') || content.match(/\]\s*\{\s*[^}]*weakSelf/)
        UI.message("üîß Applying comprehensive weakSelf fix to AgoraSurfaceViewFactory.mm...")

        # Store original content for backup
        original_content = content.dup

        # Pattern 1: Fix blocks that use weakSelf without declaration
        # Look for any block { followed by weakSelf usage
        content = content.gsub(
          /(\{\s*\n\s*)weakSelf/,
          '\1__weak typeof(self) weakSelf = self;\n        weakSelf'
        )

        # Pattern 2: Fix dispatch_async blocks specifically
        content = content.gsub(
          /dispatch_async\s*\([^)]+\)\s*\^\s*\{\s*\n\s*weakSelf/,
          "dispatch_async(dispatch_get_main_queue(), ^{\n        __weak typeof(self) weakSelf = self;\n        weakSelf"
        )

        # Pattern 3: Fix any remaining standalone weakSelf without declaration
        # Split by lines and fix each problematic usage
        lines = content.split("\n")
        fixed_lines = []
        i = 0

        while i < lines.length
          line = lines[i]

          # If this line contains weakSelf but we haven't seen a declaration
          if line.match(/\bweakSelf\b/) && !line.include?('__weak typeof(self) weakSelf')
            # Look backwards to see if there's a recent declaration
            has_recent_declaration = false
            (i-5..i-1).each do |j|
              if j >= 0 && lines[j] && lines[j].include?('__weak typeof(self) weakSelf')
                has_recent_declaration = true
                break
              end
            end

            # If no recent declaration, add one before this line
            unless has_recent_declaration
              indent = line[/^\s*/]
              fixed_lines << "#{indent}__weak typeof(self) weakSelf = self;"
            end
          end

          fixed_lines << line
          i += 1
        end

        # Join back and finalize
        content = fixed_lines.join("\n")

        # Pattern 4: Final safety check - forced fix for known problematic lines
        # Based on CI/CD error at lines 41, 44, 45 - ensure we have proper declarations
        content = content.gsub(
          /^(\s*)(.*weakSelf.*$)/,
          proc do |match|
            indentation = $1
            line_content = $2

            # Check if this line already has a declaration or is itself a declaration
            if line_content.include?('__weak typeof(self) weakSelf') ||
               line_content.match(/typeof.*weakSelf.*=/)
              match # Keep as-is if it's a declaration
            else
              # Add declaration before the line
              "#{indentation}__weak typeof(self) weakSelf = self;\n#{match}"
            end
          end
        )

        # Write the fixed content back
        File.write(agora_surface_view_factory_path, content)
        UI.success("‚úÖ Applied comprehensive weakSelf fix to AgoraSurfaceViewFactory.mm")
        UI.message("   - Original size: #{original_content.length} bytes")
        UI.message("   - Fixed size: #{content.length} bytes")

      else
        UI.message("‚ÑπÔ∏è No weakSelf usage found in AgoraSurfaceViewFactory.mm")
      end
    else
      UI.important("‚ö†Ô∏è AgoraSurfaceViewFactory.mm not found at any expected path:")
      possible_paths.each { |path| UI.important("   - #{path}") }
    end

    # Additional safety measure: Force create a simple weakSelf fix if file exists
    if File.exist?(File.expand_path("~/.pub-cache/hosted/pub.dev/agora_rtc_engine-6.5.3/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm"))
      UI.message("üõ°Ô∏è Applying emergency weakSelf fix as final safety measure...")
      emergency_fix_path = File.expand_path("~/.pub-cache/hosted/pub.dev/agora_rtc_engine-6.5.3/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm")
      emergency_content = File.read(emergency_fix_path)

      # Simple but effective fix: add weakSelf declaration at the top of any problematic method
      if emergency_content.include?('weakSelf') && !emergency_content.include?('__weak typeof(self) weakSelf = self;')
        # Find the first method that uses weakSelf and add declaration
        emergency_content = emergency_content.gsub(
          /(\{[^}]*?\n[^}]*?)(\s+)(.*weakSelf)/m,
          '\1\2__weak typeof(self) weakSelf = self;\2\3'
        )
        File.write(emergency_fix_path, emergency_content)
        UI.success("üõ°Ô∏è Applied emergency weakSelf fix")
      end
    end

    UI.success("‚úÖ Applied comprehensive post-build gRPC + Agora fixes")

  rescue => e
    UI.error("‚ùå Failed to apply gRPC/Agora fixes: #{e.message}")
    UI.error("Error details: #{e.backtrace.first(5).join('\n')}")
  end
end

platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do |options|
    # Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÁí∞Â¢É„ÇíÂèñÂæóÔºàdev/prod/appstoreÔºâ
    environment = options[:env] || "dev"

    # „Ç¢„Éó„É™ID„ÅÆË®≠ÂÆö
    app_identifier = "com.blank.sns"

    # Ë®ºÊòéÊõ∏„Å®„Éó„É≠„Éï„Ç°„Ç§„É´„ÅÆÂèñÂæóÔºàMatch‰ΩøÁî®Ôºâ
    # ÂàùÂõûË®≠ÂÆöÊôÇ„ÅØ„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà„Åó„Å¶ÊâãÂãï„ÅßË®≠ÂÆö
    # match(type: "appstore", readonly: true)

    # „Éì„É´„ÉâÁï™Âè∑„ÅÆËá™Âãï„Ç§„É≥„ÇØ„É™„É°„É≥„Éà
    increment_build_number(
      build_number: latest_testflight_build_number + 1,
      xcodeproj: "Runner.xcodeproj"
    )

    # Flutter„Éì„É´„ÉâÔºàMakefile„ÅÆ„Ç≥„Éû„É≥„Éâ„Çí‰ΩøÁî®Ôºâ
    sh("cd ../.. && make build-#{environment}")

    # TestFlight„Å∏„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
    result = upload_to_testflight(
      ipa: "../../build/ios/ipa/*.ipa",
      skip_waiting_for_build_processing: true,
      changelog: "Ëá™Âãï„Éì„É´„Éâ from #{environment} environment"
    )

    # TestFlight„ÅÆURL„Çí‰øùÂ≠òÔºàApp Store Connect„Åã„ÇâÂèñÂæóÔºâ
    testflight_url = "https://appstoreconnect.apple.com/apps/#{ENV['APP_STORE_CONNECT_APP_ID']}/testflight"
    File.write("../testflight_url.txt", testflight_url)
    UI.message("üîó TestFlight URL saved: #{testflight_url}")
  end

  desc "Build for Firebase App Distribution"
  lane :firebase do |options|
    # Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÁí∞Â¢É„ÇíÂèñÂæóÔºàdev/prodÔºâ
    environment = options[:env] || "dev"

    # „Éì„É´„ÉâÁï™Âè∑„ÅÆËá™Âãï„Ç§„É≥„ÇØ„É™„É°„É≥„Éà
    increment_build_number(
      build_number: Time.now.to_i,
      xcodeproj: "Runner.xcodeproj"
    )

    # Ë®ºÊòéÊõ∏ÁÆ°ÁêÜÔºöMatch„ÇíË©¶Ë°å„ÄÅÂ§±ÊïóÊôÇ„ÅØËá™ÂãïÁΩ≤Âêç„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    certificate_management_method = "automatic" # „Éá„Éï„Ç©„É´„Éà„ÅØËá™ÂãïÁΩ≤Âêç

    begin
      # Match‰ΩøÁî®Êù°‰ª∂„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      if ENV["MATCH_GIT_URL"] && !ENV["MATCH_GIT_URL"].empty? && ENV["FASTLANE_USER"] && !ENV["FASTLANE_USER"].empty?
        UI.message("üîê Attempting to use Fastlane Match for certificate management...")

        # Match„ÅßË®ºÊòéÊõ∏ÂèñÂæó„ÇíË©¶Ë°åÔºàreadonly mode for CI/CD safetyÔºâ
        match(
          type: "adhoc",
          app_identifier: "com.blank.sns",
          readonly: true,
          git_url: ENV["MATCH_GIT_URL"]
        )

        certificate_management_method = "match"
        UI.success("‚úÖ Fastlane Match completed successfully!")

      else
        UI.important("üîß Match requirements not met. Using automatic signing.")
        UI.important("   - MATCH_GIT_URL: #{ENV['MATCH_GIT_URL'] ? '‚úÖ' : '‚ùå'}")
        UI.important("   - FASTLANE_USER: #{ENV['FASTLANE_USER'] ? '‚úÖ' : '‚ùå'}")
        raise "Using automatic signing"
      end

    rescue => e
      UI.important("‚ö†Ô∏è  Fastlane Match not available: #{e.message}")
      UI.important("üîß Falling back to automatic signing with App Store Connect API Key...")

      # API KeyÊÉÖÂ†±„ÇíÁí∞Â¢ÉÂ§âÊï∞„Å´Ë®≠ÂÆöÔºàautomatic signing„Åß‰ΩøÁî®Ôºâ
      ENV["APP_STORE_CONNECT_API_KEY_PATH"] = File.expand_path("~/private_keys/AuthKey_#{ENV['APP_STORE_CONNECT_API_KEY_ID']}.p8")
      certificate_management_method = "automatic"
    end

    UI.message("üì± Using certificate management method: #{certificate_management_method}")

    # ÊúÄÂàù„Å´Podfile„Çí‰øÆÊ≠£„Åó„Å¶„Åã„ÇâFlutter build„ÇíÂÆüË°å
    UI.message("üîß Pre-configuring Podfile for gRPC compatibility...")

    # Flutter build„ÅÆÂâç„Å´Podfile.lock„ÇíÂâäÈô§„Åó„Å¶„ÇØ„É™„Éº„É≥„Å™Áä∂ÊÖã„Å´„Åô„Çã
    sh("rm -f Podfile.lock")

    # Flutter buildÂâç„Å´pod installÂÆüË°å„ÅßPodfile„ÅÆË®≠ÂÆö„ÇíÈÅ©Áî®
    sh("pod install")

    # Ë®ò‰∫ã„ÅÆÊàêÂäü‰æã„Å´Âü∫„Å•„ÅèÊîπÂñÑÔºöflutter build ipa„Çí‰ΩøÁî®Ôºà„Çà„ÇäÁµ±Âêà„Åï„Çå„Åü„Ç¢„Éó„É≠„Éº„ÉÅÔºâ
    # „Åì„Çå„Å´„Çà„ÇäAgora„ÅÆÂïèÈ°å„ÇíÂõûÈÅø„Åß„Åç„ÇãÂèØËÉΩÊÄß
    UI.message("üì± Building Flutter IPA with integrated approach...")

    # „Ç∑„É≥„Éó„É´„ÅßÁ¢∫ÂÆü„Å™„Éì„É´„Éâ„Ç¢„Éó„É≠„Éº„ÉÅÔºàË®ò‰∫ã„ÅÆÊàêÂäü‰æã„Å´Âü∫„Å•„ÅèÔºâ
    UI.message("üì± Building with flutter build ios (no-codesign) approach...")
    sh("cd ../.. && flutter build ios --release --dart-define-from-file=dart_defines/#{environment}.json --no-codesign")
    skip_gym = false

    # Flutter build„ÅÆÂæå„Å´„Åï„Çâ„Å´gRPC‰øÆÊ≠£„ÇíÈÅ©Áî®
    UI.message("üîß Post-Flutter build gRPC fixes...")
    apply_grpc_fixes

    # skip_gym„Éï„É©„Ç∞„ÇíËøî„Åô
    skip_gym ||= false

    # gym„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅÆ„ÅøÂÆüË°å
    unless skip_gym
      # Ë®ò‰∫ã„ÅÆÊàêÂäü‰æã„Å´Âü∫„Å•„Åè‰øÆÊ≠£ÔºöÊâãÂãïÁΩ≤Âêç„Çí‰ΩøÁî®
      # ExportOptions.plist„Çí‰ΩúÊàê
      export_options_content = {
        method: "ad-hoc",
        signingStyle: "manual",
        provisioningProfiles: {
          "com.blank.sns" => "com.blank.sns AdHoc"  # „Éó„É≠„Éï„Ç°„Ç§„É´Âêç„ÇíË™øÊï¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì
        },
        teamID: "CDQBCQRWL9",
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: false
      }

      # ExportOptions.plist„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò
      File.write("ExportOptions.plist", export_options_content.to_plist)

      # gym„Åß„Ç¢„Éº„Ç´„Ç§„Éñ+ÁΩ≤Âêç+„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºàÊàêÂäü‰æã„Å´Âü∫„Å•„ÅèË®≠ÂÆöÔºâ
      gym(
        scheme: "Runner",
        workspace: "Runner.xcworkspace",
        configuration: "Release",
        export_method: "ad-hoc",
        export_options: "ExportOptions.plist",
        clean: true,
        output_directory: "../../build/ios/ipa",
        output_name: "Runner.ipa",
        xcargs: "DEVELOPMENT_TEAM=CDQBCQRWL9"
      )
    end

    # Firebase App Distribution„Å∏„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
    firebase_params = {
      app: ENV["FIREBASE_APP_ID_IOS"],
      ipa_path: lane_context[SharedValues::IPA_OUTPUT_PATH],
      release_notes: "Ëá™Âãï„Éì„É´„Éâ from #{environment} environment"
    }

    # „ÉÜ„Çπ„Çø„ÉºË®≠ÂÆö: Áí∞Â¢ÉÂ§âÊï∞„Åæ„Åü„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅÆ„ÉÜ„Çπ„Çø„Éº„Çí‰ΩøÁî®
    if ENV["FIREBASE_TESTERS"] && !ENV["FIREBASE_TESTERS"].empty?
      UI.message("üìß Adding testers from environment variable: #{ENV["FIREBASE_TESTERS"]}")
      firebase_params[:testers] = ENV["FIREBASE_TESTERS"]
    elsif ENV["FIREBASE_TESTER_GROUPS"] && !ENV["FIREBASE_TESTER_GROUPS"].empty?
      UI.message("üë• Adding tester groups: #{ENV["FIREBASE_TESTER_GROUPS"]}")
      firebase_params[:groups] = ENV["FIREBASE_TESTER_GROUPS"]
    else
      UI.message("‚ÑπÔ∏è No specific testers configured, using default distribution settings")
    end

    result = firebase_app_distribution(firebase_params)

    # Firebase URL„Çí„Éï„Ç°„Ç§„É´„Å´Âá∫Âäõ„Åó„Å¶GitHub Actions„ÅßÂà©Áî®
    firebase_url = result ? result[:testing_uri] || result[:console_uri] : nil
    if firebase_url
      File.write("../firebase_ios_url.txt", firebase_url)
      UI.message("üîó Firebase URL saved: #{firebase_url}")
    end
  end

  desc "Setup certificates and provisioning profiles"
  lane :setup_certs do
    # Match„ÅÆÂàùÊúüË®≠ÂÆöÔºàÂàùÂõû„ÅÆ„ÅøÂÆüË°åÔºâ
    match(
      type: "development",
      app_identifier: "com.blank.sns",
      readonly: false
    )

    match(
      type: "adhoc",
      app_identifier: "com.blank.sns",
      readonly: false
    )

    match(
      type: "appstore",
      app_identifier: "com.blank.sns",
      readonly: false
    )
  end
end