default_platform(:ios)

# gRPC修正を適用するヘルパー関数（強化版）
def apply_grpc_fixes
  require 'xcodeproj'

  begin
    UI.message("🔍 Post-build gRPC fixes - Searching for targets in project...")

    # Podsディレクトリの存在確認
    unless Dir.exist?("Pods")
      UI.error("❌ Pods directory not found. Skipping gRPC fixes.")
      return
    end

    # 全てのxcconfigファイルにC++17設定を強制適用
    UI.message("📝 Applying C++17 fixes to ALL xcconfig files...")

    sh('find Pods -name "*.xcconfig" 2>/dev/null | while IFS= read -r file; do
      echo "📝 Patching $file"
      if ! grep -q "CLANG_CXX_LANGUAGE_STANDARD.*c++17" "$file" 2>/dev/null; then
        echo "CLANG_CXX_LANGUAGE_STANDARD = c++17" >> "$file"
      fi
      if ! grep -q "CLANG_CXX_LIBRARY.*libc++" "$file" 2>/dev/null; then
        echo "CLANG_CXX_LIBRARY = libc++" >> "$file"
      fi
      if ! grep -q "GCC_WARN_INHIBIT_ALL_WARNINGS.*YES" "$file" 2>/dev/null; then
        echo "GCC_WARN_INHIBIT_ALL_WARNINGS = YES" >> "$file"
      fi
      if ! grep -q "OTHER_CPLUSPLUSFLAGS.*-std=c++17" "$file" 2>/dev/null; then
        echo "OTHER_CPLUSPLUSFLAGS = \$(inherited) -std=c++17 -Wno-error=c++20-extensions -Wno-c++20-extensions" >> "$file"
      fi
      echo "✅ Patched $file"
    done')

    # Pods.xcodeprojを直接修正
    pods_project_path = "Pods/Pods.xcodeproj"
    if File.exist?(pods_project_path)
      UI.message("🔧 Directly modifying Pods project...")
      pods_project = Xcodeproj::Project.open(pods_project_path)

      pods_project.targets.each do |target|
        target.build_configurations.each do |config|
          # 全てのターゲットにC++17を強制適用
          config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++17'
          config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-std=c++17'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-error=c++20-extensions'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-c++20-extensions'
          config.build_settings['OTHER_CFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CFLAGS'] << '-Wno-error=c++20-extensions'
          config.build_settings['OTHER_CFLAGS'] << '-Wno-c++20-extensions'

          if target.name.include?('gRPC') || target.name.include?('grpc')
            config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
          end
        end
      end

      pods_project.save
      UI.success("✅ Modified Pods project directly")
    end

    # 直接プロジェクトファイルも修正
    if File.exist?("Runner.xcworkspace")
      UI.message("🔧 Also applying direct Runner project modifications...")
      project = Xcodeproj::Project.open("Runner.xcodeproj")

      project.targets.each do |target|
        target.build_configurations.each do |config|
          config.build_settings['CLANG_CXX_LANGUAGE_STANDARD'] = 'c++17'
          config.build_settings['CLANG_CXX_LIBRARY'] = 'libc++'
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] ||= ['$(inherited)']
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-std=c++17' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-std=c++17')
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-error=c++20-extensions' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-Wno-error=c++20-extensions')
          config.build_settings['OTHER_CPLUSPLUSFLAGS'] << '-Wno-c++20-extensions' unless config.build_settings['OTHER_CPLUSPLUSFLAGS'].include?('-Wno-c++20-extensions')
        end
      end

      project.save
      UI.success("✅ Applied project-level C++17 settings")
    end

    # Also fix Agora RTC Engine source code issues
    UI.message("🔧 Applying Agora RTC Engine source code fixes...")

    # Try multiple possible paths for agora_rtc_engine
    possible_paths = [
      # Pub cache path (for CI/CD)
      File.expand_path("~/.pub-cache/hosted/pub.dev/agora_rtc_engine-6.5.3/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm"),
      # Local Pods path (for local development)
      "Pods/agora_rtc_engine/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm",
      # Symlink path
      ".symlinks/plugins/agora_rtc_engine/ios/agora_rtc_engine/Sources/agora_rtc_engine/AgoraSurfaceViewFactory.mm"
    ]

    agora_surface_view_factory_path = nil
    possible_paths.each do |path|
      if File.exist?(path)
        agora_surface_view_factory_path = path
        UI.message("📁 Found AgoraSurfaceViewFactory.mm at: #{path}")
        break
      end
    end

    if agora_surface_view_factory_path
      # Read the file content
      content = File.read(agora_surface_view_factory_path)

      # Check if the file needs to be fixed (contains weakSelf usage without proper declaration)
      if content.include?('weakSelf') && !content.include?('__weak typeof(self) weakSelf = self;')
        UI.message("🔧 Applying weakSelf fix to AgoraSurfaceViewFactory.mm...")

        # Find the problematic block and add proper weakSelf declaration
        fixed_content = content.gsub(
          /dispatch_async\(dispatch_get_main_queue\(\), \^\{\s*\n\s*weakSelf/,
          "dispatch_async(dispatch_get_main_queue(), ^{\n        __weak typeof(self) weakSelf = self;\n        weakSelf"
        )

        # Alternative pattern - look for other block patterns
        fixed_content = fixed_content.gsub(
          /\^\s*\{\s*\n\s*weakSelf/,
          "^{\n        __weak typeof(self) weakSelf = self;\n        weakSelf"
        )

        # Write the fixed content back
        File.write(agora_surface_view_factory_path, fixed_content)
        UI.success("✅ Applied weakSelf fix to AgoraSurfaceViewFactory.mm")
      else
        UI.message("ℹ️ AgoraSurfaceViewFactory.mm already has proper weakSelf declaration")
      end
    else
      UI.important("⚠️ AgoraSurfaceViewFactory.mm not found at any expected path:")
      possible_paths.each { |path| UI.important("   - #{path}") }
    end

    UI.success("✅ Applied comprehensive post-build gRPC + Agora fixes")

  rescue => e
    UI.error("❌ Failed to apply gRPC/Agora fixes: #{e.message}")
    UI.error("Error details: #{e.backtrace.first(5).join('\n')}")
  end
end

platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do |options|
    # 環境変数から環境を取得（dev/prod/appstore）
    environment = options[:env] || "dev"

    # アプリIDの設定
    app_identifier = "com.blank.sns"

    # 証明書とプロファイルの取得（Match使用）
    # 初回設定時はコメントアウトして手動で設定
    # match(type: "appstore", readonly: true)

    # ビルド番号の自動インクリメント
    increment_build_number(
      build_number: latest_testflight_build_number + 1,
      xcodeproj: "Runner.xcodeproj"
    )

    # Flutterビルド（Makefileのコマンドを使用）
    sh("cd ../.. && make build-#{environment}")

    # TestFlightへアップロード
    upload_to_testflight(
      ipa: "../../build/ios/ipa/*.ipa",
      skip_waiting_for_build_processing: true,
      changelog: "自動ビルド from #{environment} environment"
    )
  end

  desc "Build for Firebase App Distribution"
  lane :firebase do |options|
    # 環境変数から環境を取得（dev/prod）
    environment = options[:env] || "dev"

    # ビルド番号の自動インクリメント
    increment_build_number(
      build_number: Time.now.to_i,
      xcodeproj: "Runner.xcodeproj"
    )

    # 証明書管理：Matchを試行、失敗時は自動署名にフォールバック
    certificate_management_method = "automatic" # デフォルトは自動署名

    begin
      # Match使用条件をチェック
      if ENV["MATCH_GIT_URL"] && !ENV["MATCH_GIT_URL"].empty? && ENV["FASTLANE_USER"] && !ENV["FASTLANE_USER"].empty?
        UI.message("🔐 Attempting to use Fastlane Match for certificate management...")

        # Matchで証明書取得を試行（readonly mode for CI/CD safety）
        match(
          type: "adhoc",
          app_identifier: "com.blank.sns",
          readonly: true,
          git_url: ENV["MATCH_GIT_URL"]
        )

        certificate_management_method = "match"
        UI.success("✅ Fastlane Match completed successfully!")

      else
        UI.important("🔧 Match requirements not met. Using automatic signing.")
        UI.important("   - MATCH_GIT_URL: #{ENV['MATCH_GIT_URL'] ? '✅' : '❌'}")
        UI.important("   - FASTLANE_USER: #{ENV['FASTLANE_USER'] ? '✅' : '❌'}")
        raise "Using automatic signing"
      end

    rescue => e
      UI.important("⚠️  Fastlane Match not available: #{e.message}")
      UI.important("🔧 Falling back to automatic signing with App Store Connect API Key...")

      # API Key情報を環境変数に設定（automatic signingで使用）
      ENV["APP_STORE_CONNECT_API_KEY_PATH"] = File.expand_path("~/private_keys/AuthKey_#{ENV['APP_STORE_CONNECT_API_KEY_ID']}.p8")
      certificate_management_method = "automatic"
    end

    UI.message("📱 Using certificate management method: #{certificate_management_method}")

    # 最初にPodfileを修正してからFlutter buildを実行
    UI.message("🔧 Pre-configuring Podfile for gRPC compatibility...")

    # Flutter buildの前にPodfile.lockを削除してクリーンな状態にする
    sh("rm -f Podfile.lock")

    # Flutter build前にpod install実行でPodfileの設定を適用
    sh("pod install")

    # Flutter iOS ビルド（署名なし）
    sh("cd ../.. && flutter build ios --release --dart-define-from-file=dart_defines/#{environment}.env --no-codesign")

    # Flutter buildの後にさらにgRPC修正を適用
    UI.message("🔧 Post-Flutter build gRPC fixes...")
    apply_grpc_fixes

    # gymでアーカイブ+署名+エクスポート（allowProvisioningUpdatesを使用）
    gym(
      scheme: "Runner",
      workspace: "Runner.xcworkspace",
      configuration: "Release",
      export_method: "ad-hoc",
      xcargs: "-allowProvisioningUpdates CODE_SIGN_STYLE=Automatic DEVELOPMENT_TEAM=CDQBCQRWL9",
      export_options: {
        signingStyle: "automatic",
        teamID: "CDQBCQRWL9",
        allowProvisioningUpdates: true
      },
      output_directory: "../../build/ios/ipa",
      output_name: "Runner.ipa"
    )

    # Firebase App Distributionへアップロード
    firebase_app_distribution(
      app: ENV["FIREBASE_APP_ID_IOS"],
      ipa_path: lane_context[SharedValues::IPA_OUTPUT_PATH],
      groups: "testers",
      release_notes: "自動ビルド from #{environment} environment"
    )
  end

  desc "Setup certificates and provisioning profiles"
  lane :setup_certs do
    # Matchの初期設定（初回のみ実行）
    match(
      type: "development",
      app_identifier: "com.blank.sns",
      readonly: false
    )

    match(
      type: "adhoc",
      app_identifier: "com.blank.sns",
      readonly: false
    )

    match(
      type: "appstore",
      app_identifier: "com.blank.sns",
      readonly: false
    )
  end
end